package CB_Core.GL_UI.libGdx_Controls.derived;

import java.util.ArrayList;
import java.util.List;

import CB_Core.Log.Logger;
import CB_Core.Math.SimplePointF;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.scenes.scene2d.Actor;
import com.badlogic.gdx.scenes.scene2d.EventListener;
import com.badlogic.gdx.scenes.scene2d.InputEvent;
import com.badlogic.gdx.scenes.scene2d.InputListener;
import com.badlogic.gdx.scenes.scene2d.Stage;
import com.badlogic.gdx.scenes.scene2d.ui.TextField;
import com.badlogic.gdx.scenes.scene2d.utils.Clipboard;
import com.badlogic.gdx.scenes.scene2d.utils.Drawable;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.FloatArray;
import com.badlogic.gdx.utils.TimeUtils;

/**
 * A wrapped text input field.
 * <p>
 * The preferred height of a text field is the height of the {@link WrappedTextFieldStyle#font} and {@link WrappedTextFieldStyle#background}
 * . The preferred width of a text field is 150, a relatively arbitrary size.
 * <p>
 * The text field will copy the currently selected text when ctrl+c is pressed, and paste any text in the clipboard when ctrl+v is pressed.
 * Clipboard functionality is provided via the {@link Clipboard} interface. Currently there are two standard implementations, one for the
 * desktop and one for Android. The Android clipboard is a stub, as copy & pasting on Android is not supported yet.
 * <p>
 * The text field allows you to specify an {@link OnscreenKeyboard} for displaying a softkeyboard and piping all key events generated by the
 * keyboard to the text field. There are two standard implementations, one for the desktop and one for Android. The desktop keyboard is a
 * stub, as a softkeyboard is not needed on the desktop. The Android {@link OnscreenKeyboard} implementation will bring up the default IME.
 * 
 * @author mzechner
 */
public class WrappedTextField extends TextField
{

	public int CursorLine = 0;
	public int CursorRow = 0;
	public int lineCount = 0;
	private float offsetY = 0;

	private ArrayList<SimplePointF> glyphPointF = new ArrayList<SimplePointF>();
	private int[] lineCharCount;
	private boolean[] lineEndsWidthLineBreak;

	public WrappedTextField(String text, TextFieldStyle style)
	{
		super(text, style);
		initialize();
	}

	private void initialize()
	{
		Array<EventListener> listners = getListeners();

		for (EventListener eventListner : listners)
		{
			if (eventListner instanceof InputListener) removeListener(eventListner);
		}

		addListener(new InputListener()
		{
			public boolean touchDown(InputEvent event, float x, float y, int pointer, int button)
			{
				Logger.LogCat("Offset:" + offsetY);
				mLastTouch = y;
				mLastTouchOffset = offsetY;
				return true;
			}

			public boolean keyDown(InputEvent event, int keycode)
			{
				Logger.LogCat("KeyDown: " + keycode);

				final BitmapFont font = style.font;

				Stage stage = getStage();
				if (stage != null && stage.getKeyboardFocus() == WrappedTextField.this)
				{
					if (Gdx.input.isKeyPressed(Keys.CONTROL_LEFT) || Gdx.input.isKeyPressed(Keys.CONTROL_RIGHT))
					{
						// paste
						if (keycode == Keys.V) paste();
						// copy
						if (keycode == Keys.C || keycode == Keys.INSERT) copy();
						calculateOffsets();
					}
					else if (Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Keys.SHIFT_RIGHT))
					{
						// paste
						if (keycode == Keys.INSERT) paste();
						// cut
						if (keycode == Keys.FORWARD_DEL)
						{
							if (hasSelection)
							{
								copy();
								delete();
							}
						}
						// selection
						if (keycode == Keys.LEFT)
						{
							if (!hasSelection)
							{
								selectionStart = cursor;
								hasSelection = true;
							}
							cursor--;
						}
						if (keycode == Keys.RIGHT)
						{
							if (!hasSelection)
							{
								selectionStart = cursor;
								hasSelection = true;
							}
							cursor++;
						}
						if (keycode == Keys.HOME)
						{
							if (!hasSelection)
							{
								selectionStart = cursor;
								hasSelection = true;
							}
							cursor = 0;
						}
						if (keycode == Keys.END)
						{
							if (!hasSelection)
							{
								selectionStart = cursor;
								hasSelection = true;
							}
							cursor = text.length();
						}

					}
					else
					{

						// cursor movement or other keys (kill selection)
						if (keycode == Keys.LEFT)
						{
							cursor--;
							clearSelection();
						}
						if (keycode == Keys.RIGHT)
						{
							cursor++;
							clearSelection();
						}

						if (keycode == Keys.UP)
						{
							cursorLinUpDown(-1);
							clearSelection();
						}
						if (keycode == Keys.DOWN)
						{
							cursorLinUpDown(1);
							clearSelection();
						}

						if (keycode == Keys.HOME)
						{
							cursor = 0;
							clearSelection();
						}
						if (keycode == Keys.END)
						{
							cursor = text.length();
							clearSelection();
						}

					}

					cursor = Math.max(0, cursor);
					cursor = Math.min(text.length(), cursor);
					calculateOffsets();

					return true;
				}
				return false;
			}

			public boolean keyUp(InputEvent event, int keycode)
			{
				Logger.LogCat("KeyUp" + keycode);
				return true;
			}

			public boolean keyTyped(InputEvent event, char character)
			{
				Logger.LogCat("keyTyped: " + character);

				int realCursorPos = getRealCusorPos();
				int versatz = cursor - realCursorPos;

				final BitmapFont font = style.font;

				if (getStage() != null && getStage().getKeyboardFocus() == WrappedTextField.this)
				{
					if (character == BACKSPACE && (realCursorPos > 0 || hasSelection))
					{
						if (!hasSelection)
						{
							text = text.substring(0, realCursorPos - 1) + text.substring(realCursorPos);
							updateDisplayText();
							realCursorPos--;
						}
						else
						{
							delete();
						}
					}
					if (character == DELETE)
					{
						if (realCursorPos < text.length() || hasSelection)
						{
							if (!hasSelection)
							{
								text = text.substring(0, realCursorPos) + text.substring(realCursorPos + 1);
								updateDisplayText();
							}
							else
							{
								delete();
							}
						}
						calcLineRow();
						return true;
					}
					if (character != ENTER_DESKTOP && character != ENTER_ANDROID)
					{
						if (filter != null && !filter.acceptChar(WrappedTextField.this, character)) return true;
					}

					if (character == TAB) next(Gdx.input.isKeyPressed(Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Keys.SHIFT_RIGHT));

					if (character == ENTER_DESKTOP) character = ENTER_ANDROID;

					if (font.containsCharacter(character) || character == ENTER_ANDROID)
					{
						if (!hasSelection)
						{
							text = text.substring(0, realCursorPos) + character + text.substring(realCursorPos, text.length());
							updateDisplayText();
							realCursorPos++;
						}
						else
						{
							int minIndex = Math.min(realCursorPos, selectionStart);
							int maxIndex = Math.max(realCursorPos, selectionStart);

							text = (minIndex > 0 ? text.substring(0, minIndex) : "")
									+ (maxIndex < text.length() ? text.substring(maxIndex, text.length()) : "");
							realCursorPos = minIndex;
							text = text.substring(0, realCursorPos) + character + text.substring(realCursorPos, text.length());
							updateDisplayText();
							realCursorPos++;
							clearSelection();
						}

					}

					cursor = realCursorPos + versatz;

					if (listener != null) listener.keyTyped(WrappedTextField.this, character);
					calcLineRow();
					return true;
				}
				else
					return false;
			}

			public void touchDragged(InputEvent event, float x, float y, int pointer)
			{
				offsetY = mLastTouchOffset + (y - mLastTouch);
				if (offsetY < 0)
				{
					offsetY = 0;
					return;
				}

				float lineHeight = style.font.getLineHeight();

				float maxYPos = lineCount * lineHeight / 2;
				if (offsetY > maxYPos)
				{
					offsetY = maxYPos;
				}
			}

		});
	}

	private void calculateOffsets()
	{
		Logger.LogCat("CalcOffset");
		offsetY = 0;
		float lineHeight = style.font.getLineHeight();
		int lastVisibleLine = (int) ((this.getHeight() - this.style.background.getBottomHeight() - this.style.background.getTopHeight()) / lineHeight) - 1;

		if (CursorLine > lastVisibleLine)
		{
			offsetY = (CursorLine - lastVisibleLine) * lineHeight;
		}

		if (true) return;

	}

	public static int debugCursorPos = 0;
	public static int debugLineCount = 0;
	public static int debugCursorLine = 0;
	public static int debugCursorRow = 0;
	public static String debugCharBeforCursor = "";
	public static int debugRealCursorPos = 0;

	@Override
	public void draw(SpriteBatch batch, float parentAlpha)
	{
		final BitmapFont font = style.font;
		final Color fontColor = style.fontColor;

		final Drawable selection = style.selection;
		final Drawable cursorPatch = style.cursor;

		Color color = getColor();
		{
			// Debug
			debugCursorPos = cursor;
			debugLineCount = lineCount;
			debugCursorRow = CursorRow;
			debugCursorLine = CursorLine;

			debugCharBeforCursor = debugVorCursor();

			debugRealCursorPos = getRealCusorPos();
		}

		batch.setColor(color.r, color.g, color.b, color.a * parentAlpha);
		float bgLeftWidth = 0;
		float bgRightWidth = 0;
		float bgTopHeight = 0;
		if (style.background != null)
		{
			style.background.draw(batch, getX(), getY(), getWidth(), getHeight());
			bgLeftWidth = style.background.getLeftWidth();
			bgRightWidth = style.background.getRightWidth();
			bgTopHeight = style.background.getTopHeight();

		}

		float textY = (int) (getHeight() + font.getDescent() - bgTopHeight);

		textY += offsetY;

		boolean focused = getStage() != null && getStage().getKeyboardFocus() == this;
		if (focused && hasSelection && selection != null)
		{
			selection.draw(batch, getX() + selectionX + bgLeftWidth + renderOffset, getY() + textY - textBounds.height - font.getDescent()
					/ 2, selectionWidth, textBounds.height);
		}

		if (displayText.length() == 0)
		{
			if (!focused && messageText != null)
			{
				if (style.messageFontColor != null)
				{
					font.setColor(style.messageFontColor.r, style.messageFontColor.g, style.messageFontColor.b, style.messageFontColor.a
							* parentAlpha);
				}
				else
					font.setColor(0.7f, 0.7f, 0.7f, parentAlpha);
				BitmapFont messageFont = style.messageFont != null ? style.messageFont : font;
				font.draw(batch, messageText, getX() + bgLeftWidth, getY() + textY);
			}
		}
		else
		{
			font.setColor(fontColor.r, fontColor.g, fontColor.b, fontColor.a * parentAlpha);
			// font.draw(batch, displayText, x + bgLeftWidth + textOffset, y + textY, visibleTextStart, visibleTextEnd);
			font.drawWrapped(batch, displayText, getX() + bgLeftWidth + textOffset, getY() + textY, getWidth() - bgLeftWidth - bgRightWidth);
		}
		if (focused)
		{
			blink();
			if (cursorOn && cursorPatch != null)
			{
				float lineHeight = font.getLineHeight();

				float cX = 0;
				float cY = 0;

				if (glyphPointF == null || glyphPointF.size() <= cursor)
				{

				}
				else
				{
					cX = glyphPointF.get(cursor).x;
					cY = glyphPointF.get(cursor).y;
				}

				cursorPatch.draw(batch, getX() + bgLeftWidth + cX + renderOffset - 1, getY() + textY - lineHeight - font.getDescent() - cY,
						cursorPatch.getMinWidth(), lineHeight + font.getDescent() / 2);

			}
		}
	}

	String debugVorCursor()
	{

		// String ret = "" + displayText.charAt(Math.max(getRealCusorPos() - 1, 0));

		String ret = "" + displayText.subSequence((Math.max(cursor - 1, 0)), displayText.length());

		ret = ret.replace("/n", "//N");

		return ret;
	}

	private int getRealCusorPos()
	{
		if (CursorLine < 0 || lineEndsWidthLineBreak == null) return 0;

		int ret = 0;

		for (int i = 0; i < CursorLine; i++)
		{
			if (lineEndsWidthLineBreak[i]) ret++;
		}
		ret = cursor - (CursorLine - ret);

		return ret;
	}

	private int replaseLineBreak(String str, int replace)
	{
		int pos = str.indexOf("\n");
		if (pos > 0)
		{
			replace++;
			str = str.replaceFirst("\n", "");
		}

		pos = str.indexOf("\r");
		if (pos > 0)
		{
			replace++;
			str = str.replaceFirst("\r", "");
		}

		if (str.contains("\n") || str.contains("\r"))
		{
			replace = replaseLineBreak(str, replace);
		}

		return replace;
	}

	private void updateDisplayText()
	{
		if (passwordMode && style.font.containsCharacter(passwordCharacter))
		{
			if (passwordBuffer == null) passwordBuffer = new StringBuilder(text.length());
			if (passwordBuffer.length() > text.length()) //
			passwordBuffer.setLength(text.length());
			else
			{
				for (int i = passwordBuffer.length(), n = text.length(); i < n; i++)
					passwordBuffer.append(passwordCharacter);
			}
			displayText = passwordBuffer;
		}
		else
			displayText = text;

		calcTextBounds();
	}

	private void blink()
	{
		long time = TimeUtils.nanoTime();
		if ((time - lastBlink) / 1000000000.0f > blinkTime)
		{
			cursorOn = !cursorOn;
			lastBlink = time;
		}
	}

	public boolean click(int x, int y, int pointer, int button)
	{
		if (pointer != 0) return false;

		if (getStage() != null) getStage().setKeyboardFocus(this);
		keyboard.show(true);
		clearSelection();
		lastBlink = 0;
		cursorOn = false;

		if (lineCharCount == null || lineCharCount.length == 0)
		{
			cursor = 0;
			return true;
		}

		float lineHeight = style.font.getLineHeight();
		float clickPos = y - offsetY;
		int clickedCursorLine = (int) ((this.getHeight() - clickPos + (lineHeight / 2)) / lineHeight) - 1;

		if (clickedCursorLine >= lineCount) return true;

		int lineBeginn = 0;
		for (int l = 0; l < clickedCursorLine; l++)
		{
			lineBeginn += lineCharCount[l];
		}

		for (int i = lineBeginn; i < glyphPositions.size; i++)
		{
			float pos = glyphPositions.items[i];
			if ((pos > x) | (i - lineBeginn >= lineCharCount[clickedCursorLine] - 1))
			{
				cursor = Math.max(0, i - 1);
				return true;
			}
		}
		cursor = Math.max(0, glyphPositions.size - 1);
		calcLineRow();
		return true;
	}

	private float mLastTouch = 0;
	private float mLastTouchOffset = 0;

	// @Override
	// public void touchDragged(float x, float y, int pointer)
	// {

	// }

	private void cursorLinUpDown(int value)
	{
		CursorLine += value;

		if (CursorLine < 0)
		{
			CursorLine = 0;
			return;
		}

		if (CursorLine > lineCount - 1)
		{
			CursorLine = lineCount - 1;
			return;
		}

		int calcedCursor = 0;
		for (int i = 0; i < CursorLine; i++)
		{
			calcedCursor += lineCharCount[i];
			if (!lineEndsWidthLineBreak[i]) calcedCursor++;
		}

		int row = CursorRow;

		if (lineCharCount[CursorLine] < CursorRow) row = lineCharCount[CursorLine] - 1;

		cursor = calcedCursor + row;
		calculateOffsets();
	}

	private void delete()
	{
		int minIndex = Math.min(cursor, selectionStart);
		int maxIndex = Math.max(cursor, selectionStart);
		text = (minIndex > 0 ? text.substring(0, minIndex) : "")
				+ (maxIndex < text.length() ? text.substring(maxIndex, text.length()) : "");
		updateDisplayText();
		cursor = minIndex;
		clearSelection();
	}

	/**
	 * Focuses the next TextField. If none is found, the keyboard is hidden. Does nothing if the text field is not in a stage.
	 * 
	 * @param up
	 *            If true, the TextField with the same or next smallest y coordinate is found, else the next highest.
	 */
	public void next(boolean up)
	{
		if (getStage() == null) return;
		TextField textField = findNextTextField(getStage().getActors(), null, up);
		if (textField != null) getStage().setKeyboardFocus(textField);
		else
			Gdx.input.setOnscreenKeyboardVisible(false);
	}

	private WrappedTextField findNextTextField(List<Actor> actors, WrappedTextField best, boolean up)
	{
		for (int i = 0, n = actors.size(); i < n; i++)
		{
			Actor actor = actors.get(i);
			if (actor instanceof WrappedTextField)
			{
				if (actor == this) continue;
				if (actor.getY() == getY())
				{
					if (best == null && actor.getX() >= getX() ^ up) best = (WrappedTextField) actor;
				}
				else if (actor.getY() < getY() ^ up && (best == null || actor.getY() - getY() > best.getY() - getY() ^ up))
				{
					best = (WrappedTextField) actor;
				}
			}
			// if (actor instanceof Group) best = findNextTextField(((Group) actor).getActors(), best, up);
		}
		return best;
	}

	/**
	 * @param listener
	 *            May be null.
	 */
	public void setTextFieldListener(TextFieldListener listener)
	{
		this.listener = listener;
	}

	/**
	 * @param filter
	 *            May be null.
	 */
	public void setTextFieldFilter(TextFieldFilter filter)
	{
		this.filter = filter;
	}

	/** @return May be null. */
	public String getMessageText()
	{
		return messageText;
	}

	/**
	 * Sets the text that will be drawn in the text field if no text has been entered.
	 * 
	 * @parma messageText May be null.
	 */
	public void setMessageText(String messageText)
	{
		this.messageText = messageText;
	}

	public void setText(String text)
	{
		if (text == null) throw new IllegalArgumentException("text cannot be null.");

		this.text = text.replace("\r\n", "\n");

		updateDisplayText();
		cursor = 0;
		clearSelection();

		// textBounds.set(font.getBounds(displayText));
		calcTextBounds();

	}

	private void calcTextBounds()
	{
		if (getWidth() == 0 || style == null) return;
		BitmapFont font = style.font;
		float bgLeftWidth = 0;
		float bgRightWidth = 0;
		if (style.background != null)
		{
			bgLeftWidth = style.background.getLeftWidth();
			bgRightWidth = style.background.getRightWidth();

		}

		float wrapWidth = getWidth() - bgLeftWidth - bgRightWidth;
		int lines = (int) (font.getWrappedBounds(displayText, wrapWidth).height / font.getLineHeight() + 1);
		lineCharCount = new int[lines];
		lineEndsWidthLineBreak = new boolean[lines];
		int start = 0;
		int numLines = 0;
		int length = displayText.length();
		float maxWidth = 0;

		glyphAdvances.clear();
		glyphPositions.clear();
		glyphPointF.clear();

		while (start < length)
		{
			int newLine = WrappedTextField.indexOf(displayText, '\n', start);
			// Eat whitespace at start of line.
			while (start < newLine)
			{
				if (!WrappedTextField.isWhitespace(displayText.charAt(start))) break;
				start++;
			}
			int lineEnd = start + font.computeVisibleGlyphs(displayText, start, newLine, wrapWidth);
			if (lineEnd + 1 < displayText.length()) lineEnd++;
			int nextStart = lineEnd;
			if (lineEnd < newLine)
			{
				// Find char to break on.
				while (lineEnd > start)
				{
					if (WrappedTextField.isWhitespace(displayText.charAt(lineEnd)))
					{
						lineEnd++;
						break;
					}
					lineEnd--;
				}
				if (lineEnd == start) lineEnd = nextStart; // If no characters to break, show all.
				else
				{
					nextStart = lineEnd;
					// Eat whitespace at end of line.
					// while (lineEnd > start)
					// {
					// if (!WrappedTextField.isWhitespace(displayText.charAt(lineEnd))) break;
					// lineEnd--;
					// }
				}
			}

			int CharCount = 0;

			if (lineEnd > start)
			{
				// one line

				float lineWidth = font.getBounds(displayText, start, lineEnd).width;
				maxWidth = Math.max(maxWidth, lineWidth);
				FloatArray lineGlyphAdvances = new FloatArray();
				FloatArray lineGlyphPositions = new FloatArray();

				CharSequence lineChars = displayText.subSequence(start, lineEnd);
				CharCount = lineChars.length();
				if (((String) lineChars).endsWith("\n"))
				{

					lineEndsWidthLineBreak[numLines] = true;

				}
				else
				{
					lineEndsWidthLineBreak[numLines] = false;
				}

				// Hier ist die letzte glyph weite immr 0.0
				font.computeGlyphAdvancesAndPositions(lineChars, lineGlyphAdvances, lineGlyphPositions);

				for (int i = 0; i < lineGlyphPositions.size; i++)
				{

					glyphPointF.add(new SimplePointF(lineGlyphPositions.get(i), numLines * font.getLineHeight()));

				}

				glyphAdvances.addAll(lineGlyphAdvances);
				glyphPositions.addAll(lineGlyphPositions);
			}

			if (lineCharCount.length - 1 < numLines) return;

			lineCharCount[numLines] = CharCount;
			start = nextStart;
			numLines++;
			if (lineCharCount.length < numLines) break;
		}

		glyphAdvances.add(0);
		glyphPositions.add(getWidth());

		textBounds.width = maxWidth;
		textBounds.height = (font.getData().capHeight + (numLines - 1) * font.getData().lineHeight) - font.getDescent() * 2;

		// font.computeGlyphAdvancesAndPositions(displayText, glyphAdvances, glyphPositions);

		lineCount = numLines;

		calcLineRow();
	}

	private void calcLineRow()
	{
		if (lineCharCount != null && lineCharCount.length > 0)
		{
			int count = 0;
			for (int i = 0; i < lineCharCount.length; i++)
			{
				// falsche berechnung bei Wraped Line

				boolean endWithLineBreak = lineEndsWidthLineBreak[i];
				if (!endWithLineBreak) count++;
				count += lineCharCount[i];
				if (cursor < count)
				{
					if (!endWithLineBreak) count--;
					CursorLine = i;
					CursorRow = count - lineCharCount[i] - cursor;
					if (CursorRow < 0) CursorRow *= -1;
					break;
				}
			}
		}
	}

	static int indexOf(CharSequence text, char ch, int start)
	{
		final int n = text.length();
		for (; start < n; start++)
			if (text.charAt(start) == ch) return start;
		return n;
	}

	static boolean isWhitespace(char c)
	{
		switch (c)
		{
		case '\n':
		case '\r':
		case '\t':
		case ' ':
			return true;
		default:
			return false;
		}
	}

	/** Sets the selected text. */
	public void setSelection(int selectionStart, int selectionEnd)
	{
		if (selectionStart < 0) throw new IllegalArgumentException("selectionStart must be >= 0");
		if (selectionEnd < 0) throw new IllegalArgumentException("selectionEnd must be >= 0");
		selectionStart = Math.min(text.length(), selectionStart);
		selectionEnd = Math.min(text.length(), selectionEnd);
		if (selectionEnd == selectionStart)
		{
			clearSelection();
			return;
		}
		if (selectionEnd < selectionStart)
		{
			int temp = selectionEnd;
			selectionEnd = selectionStart;
			selectionStart = temp;
		}

		hasSelection = true;
		this.selectionStart = selectionStart;
		cursor = selectionEnd;
	}

	public void clearSelection()
	{
		hasSelection = false;
		calcLineRow();
	}

	public float getMesuredHeight()
	{
		return textBounds.height;
	}

}
